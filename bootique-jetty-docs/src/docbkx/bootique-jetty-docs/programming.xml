<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="programming">
    <title>Programming Jetty Applications</title>
    <para>You can keep writing servlet specification objects (servlets, filters, listeners) as you'd
        do it under JavaEE, except that there's no <code>.war</code> and no <code>web.xml</code>.
        There's only your application, and you need to let Bootique know about your objects and how
        they should be mapped to request URLs. Let's start with servlets.</para>
    <section>
        <title>Servlets</title>
        <para>The easiest way to add a servlet to a Bootique app is to first annotate it with
                <code>@WebServlet</code>, providing name and url
            patterns:<programlisting language="java">@WebServlet(
	name = "myservlet", 
	urlPatterns = "/b", 
	initParams = { 
		@WebInitParam(name = "p1", value = "v1"),
		@WebInitParam(name = "p2", value = "v2") 
	}
)
public class AnnotatedServlet extends HttpServlet { .. }</programlisting>
            The "name" property is kind of important as it would allow to override annotation values
            in the YAML, as described in the "Configuration Reference" chapter. Servlet created this
            way can inject any services it might need using normal Guice injection. Now it can be
            added to Bootique via <code>JettyModule</code> contribution API inside your application
            Module:<programlisting language="java">@Override
public void configure(Binder binder) {
	JettyModule.contributeServlets(binder).addBinding().to(AnnotatedServlet.class);
}</programlisting>But
            what if you are deploying a third-party servlet that is not annotated? Or annotation
            values are off in the context of your application? There are two choices. The first is
            to subclass such servlets and annotate the subclasses that you control. </para>
        <para>The second is to wrap your servlet in a special metadata object called
                <code>MappedServlet</code>, providing all the mapping information in that wrapper.
            This is a bit too verbose, but can be a good way to define the mapping that is not
            otherwise
            available:<programlisting>@Override
public void configure(Binder binder) {
    MappedServlet mappedServlet = new MappedServlet(
       new MyServlet(), 
       Collections.singleton("/c"),
       "myservlet");

    JettyModule.contributeMappedServlets(binder).addBinding().toInstance(mappedServlet);
}</programlisting></para>
    </section>
    <section>
        <title>Servlet Filters</title>
    </section>
    <section>
        <title>Listeners</title>
    </section>
    <section>
        <title>Serving Static Files</title>
    </section>
</chapter>
